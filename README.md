# password-checker
This program checks passwords based on NIST Guidelines (SP 800-63B). So one key point that my program implements is that there is no requirement for special characters, upper/lower case characters, numbers, etc. In the guidelines, NIST recommends not having a set of rules dictating how passwords should be because having requirements makes the password more predictable/decreases entropy. To compensate for this, my code goes through some checks to ensure that the password is strong.
First up is the length check. NIST recommends having at least 8 characters in a password and having a minimum maximum of 64 characters to allow for phrases as well. In my program, I implemented a maximum of 64 characters, because realistically, if you aren't using a password manager, it's going to be really hard to remember the password if it's too long.
The next check is my favorite: it checks a set of compromised/common passwords to see if the password was compromised in a breach. NIST recommends checking the password against a common password. The set is composed of the first 100,000 passwords from the RockYou breach in 2009 (you can download the dataset here: https://www.kaggle.com/datasets/wjburns/common-password-list-rockyoutxt?resource=download). I used a set to add the passwords because it is much more efficient at seeing if the password is in the compromised dataset.
The next check is simple: it simply checks if the password consists of only one character repeated ("aaaaaa") by putting the characters in a set, then checking if the length of the set is 1.
The last check was the trickiest part of writing this program. It checks to see if the password consists only of a repeating pattern ("abcabcabc"). It does this by iterating through the characters of the password and checking if they repeat multiple times to form the password. It was challenging to determine how many times I should multiply the pattern to obtain the password, but I ultimately used floor division to divide the length of the entire password by the length of the pattern, then multiplied that result by the pattern to check if it formed the password.
The last function is the main function, which is basically like a UI within the terminal that asks the user to add a password, then what check they want to do. The last "e" check checks everything, then gives the user a score based on how many checks it fulfills. 
